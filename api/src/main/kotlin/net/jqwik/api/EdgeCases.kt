package net.jqwik.api

import org.apiguardian.api.API
import java.util.function.Consumer
import java.util.function.Predicate
import java.util.function.Supplier

@API(status = API.Status.EXPERIMENTAL, since = "1.3.0")
interface EdgeCases<out T> : Iterable<Shrinkable<T>> {
    @API(status = API.Status.INTERNAL)
    abstract class EdgeCasesFacade {
        abstract fun <T> fromSuppliers(suppliers: List<Supplier<Shrinkable<T>>>): EdgeCases<T>

        companion object {
            val implementation = FacadeLoader.load(
                EdgeCasesFacade::class.java
            )
        }
    }

    @API(status = API.Status.EXPERIMENTAL, since = "1.3.9")
    interface Config<T> {
        /**
         * Don't use any of the default edge cases
         *
         * @return same configuration instance
         */
        fun none(): Config<T>

        /**
         * Only include default edge cases for which [.filter]  returns true
         *
         * @param filter A predicate
         * @return same configuration instance
         */
        fun filter(filter: Predicate<in T>): Config<T>

        /**
         * Add one or more unshrinkable additional values as edge cases.
         *
         *
         *
         * Some arbitraries may allow those values to be outside the value range generated by this arbitrary;
         * this is mainly due to implementation issues.
         * In general you should not add "forbidden" values since it will weaken the semantics
         * of built-in constraints.
         *
         *
         * @param edgeCases The edge cases to add to default edge cases.
         * @return same configuration instance
         */
        fun add(vararg edgeCases: T): Config<T>

        /**
         * Include only the values given; and only if they are in the set of default edge cases
         *
         * @param includedValues The values to be included
         * @return same configuration instance
         */
        fun includeOnly(vararg includedValues: T): Config<T>

        companion object {
            @JvmStatic
			fun <T> noConfig(): Consumer<Config<T>> {
                return Consumer { config: Config<T> -> }
            }
        }
    }

    fun suppliers(): List<Supplier<Shrinkable<@UnsafeVariance T>>>
    fun size(): Int {
        return suppliers().size
    }

    val isEmpty: Boolean
        get() = size() == 0

    override fun iterator(): MutableIterator<Shrinkable<T>> {
        return suppliers().stream().map { obj: Supplier<Shrinkable<T>> -> obj.get() }
            .iterator()
    }

    companion object {
        @JvmStatic
		@API(status = API.Status.INTERNAL)
        fun <T> fromSuppliers(suppliers: List<Supplier<Shrinkable<T>>>): EdgeCases<T> {
            return EdgeCasesFacade.implementation!!.fromSuppliers(suppliers)
        }

        @JvmStatic
		@API(status = API.Status.INTERNAL)
        fun <T> none(): EdgeCases<T> {
            return fromSuppliers(emptyList<Supplier<Shrinkable<T>>>())
        }

        @JvmStatic
		@API(status = API.Status.INTERNAL)
        fun <T> fromSupplier(supplier: Supplier<Shrinkable<T>>): EdgeCases<T> {
            return fromSuppliers(listOf(supplier))
        }
    }
}